pipeline {
    agent {
        label 'aws_linux_agents' // Target agents with pre-installed dependencies
    }

    environment {
        DOCKER_USERNAME = 'devgixa'
        DOCKER_IMAGE_FRONTEND = 'devgixa/frontend-service'
        DOCKER_IMAGE_BACKEND = 'devgixa/backend-service'
        BUILD_TAG = "latest-${env.BUILD_ID}" // Unique tag per build
        NETWORK_NAME = 'app-network'
        BACKEND_PORT = '4040'
        SSH_USER = 'ubuntu'
        TF_PLUGIN_CACHE_DIR = "${WORKSPACE}/.terraform.d/plugin-cache" // Cache directory
    }

    tools {
        terraform 'tf_1.11.3' // Configured in Jenkins Global Tools
    }

    stages {
        stage('SCM Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: 'main']],
                    extensions: [
                        [
                            $class: 'CleanBeforeCheckout',
                            deleteUntrackedNestedRepositories: true
                        ]
                    ],
                    userRemoteConfigs: [[
                        url: 'https://github.com/GiharaNavindu/talks-dev.git',
                        credentialsId: 'github-credentials'
                    ]]
                ])
            }
        }

        stage('Build and Push Docker Images') {
            steps {
                script {
                    parallel(
                        frontend: {
                            docker.build("${DOCKER_IMAGE_FRONTEND}:${BUILD_TAG}", "./client")
                            docker.withRegistry('https://registry-1.docker.io/v2/', 'dockerhub-creds') {
                                docker.image("${DOCKER_IMAGE_FRONTEND}:${BUILD_TAG}").push()
                            }
                        },
                        backend: {
                            docker.build("${DOCKER_IMAGE_BACKEND}:${BUILD_TAG}", "./api")
                            docker.withRegistry('https://registry-1.docker.io/v2/', 'dockerhub-creds') {
                                docker.image("${DOCKER_IMAGE_BACKEND}:${BUILD_TAG}").push()
                            }
                        }
                    )
                }
            }
        }

        stage('Terraform Provisioning') {
            environment {
                AWS_REGION = 'us-east-1'
            }
            
            stages {
                stage('Initialize') {
                    steps {
                        dir('terraform') {
                            script {
                                // Reuse existing initialization if available
                                sh 'terraform version'
                                sh 'mkdir -p ${TF_PLUGIN_CACHE_DIR}'
                                sh '''
                                    if [ ! -d ".terraform" ]; then
                                        terraform init -backend-config="region=${AWS_REGION}" \
                                        -plugin-dir=${TF_PLUGIN_CACHE_DIR}
                                    fi
                                '''
                            }
                        }
                    }
                }

                stage('Apply') {
                    steps {
                        dir('terraform') {
                            withCredentials([[
                                $class: 'AmazonWebServicesCredentialsBinding',
                                accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                                secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                            ]]) {
                                sh 'terraform apply -auto-approve -compact-warnings'
                                script {
                                    env.EC2_PUBLIC_IP = sh(
                                        script: 'terraform output -raw instance_ip',
                                        returnStdout: true
                                    ).trim()
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('EC2 Deployment') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'ec2-ssh-key', variable: 'SSH_KEY')]) {
                        sh """
                            # Install Docker
                            ssh -o StrictHostKeyChecking=no -i ${SSH_KEY} ${SSH_USER}@${env.EC2_PUBLIC_IP} '
                                sudo apt-get update -qq -y
                                sudo apt-get install -qq -y docker.io
                                sudo systemctl enable docker
                                sudo usermod -aG docker ${SSH_USER}
                            '

                            # Deploy Services
                            ssh -i ${SSH_KEY} ${SSH_USER}@${env.EC2_PUBLIC_IP} '
                                docker network create ${NETWORK_NAME} || true
                                docker run -d --rm \
                                    --name backend \
                                    --network ${NETWORK_NAME} \
                                    -p ${BACKEND_PORT}:${BACKEND_PORT} \
                                    ${DOCKER_IMAGE_BACKEND}:${BUILD_TAG}
                                
                                docker run -d --rm \
                                    --name frontend \
                                    --network ${NETWORK_NAME} \
                                    -p 80:5173 \
                                    ${DOCKER_IMAGE_FRONTEND}:${BUILD_TAG}
                            '
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                docker.withRegistry('https://registry-1.docker.io/v2/', 'dockerhub-creds') {
                    sh 'docker logout'
                }
            }
            cleanWs()
        }
        success {
            slackSend(color: 'good', message: "Deployment SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}")
        }
        failure {
            slackSend(color: 'danger', message: "Deployment FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}")
        }
    }
}
